<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="日常工作中的一些知识点记录和备份，用于后期查看">
    

    <!--Author-->
    
        <meta name="author" content="christian_smile">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="iOS开发之ffmpeg">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="日常工作中的一些知识点记录和备份，用于后期查看">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="45°仰望星空">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>iOS开发之ffmpeg - 45°仰望星空</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>iOS开发之ffmpeg</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2019-08-14
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="在mac平台安装ffmpeg"><a href="#在mac平台安装ffmpeg" class="headerlink" title="在mac平台安装ffmpeg"></a>在mac平台安装ffmpeg</h3><p>安装分为源码安装和命令行安装，关于这部分的教程网上非常多，所以我只介绍一种简单的安装-&gt;命令行安装。</p>
<p>我们使用<code>brew</code>来安装ffmpeg和ffplay命令。</p>
<p>关于<code>brew</code>以及其用法可参考 <a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F4e80b42823d5" target="_blank" rel="noopener">Homebrew的安装及使用</a></p>
<p>空白安装：</p>
<p>如果你的电脑上以前从来没有安装过<code>ffmpeg</code>，那么你可以直接使用以下命令直接安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg --with-ffplay</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>安装成功后可以使用<code>ffplay --help</code>来检测是否成功安装。</p>
<p>非空白安装：</p>
<p>如果你的电脑上以前安装了<code>ffmpeg</code>，那么你需要把以前安装的<code>ffmpeg</code>卸载干净然后再利用上面的命令安装。</p>
<p>卸载方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall ffmpeg</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>你也可以直接在ffmpeg官网下载ffmpeg,ffplay等命令行工具，直接拷贝到你的bin目录下，直接运行也可以。 此部分主要目的就是能在mac上利用利用ffmpeg命令行工具来解析音视频文件。</p>
<h3 id="简单常用的ffmpeg命令"><a href="#简单常用的ffmpeg命令" class="headerlink" title="简单常用的ffmpeg命令"></a>简单常用的ffmpeg命令</h3><p>关于ffmpeg的命令，最好的途径是直接在其官网上查看。网上也有很多的示例，有些比较简单的命令用的多了自然就习惯性的记着了。以下我贴出的是在一本书上看的最常见的命令，具体如下：</p>
<h4 id="ffprobe"><a href="#ffprobe" class="headerlink" title="ffprobe"></a>ffprobe</h4><p>ffprobe是用来查看媒体文件头信息的工具。</p>
<ul>
<li><p>查看音频文件头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffprobe 黄昏里.mp3</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>显示结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Input #0, mp3, from ‘黄昏里.mp3’:<br>  Metadata:<br>    title           : 黄昏里<br>    artist          : 邓丽君<br>    album           : 爱的箴言<br>    Tagging time    : 2012-08-08T02:48:38<br>    TYER            : 1998-01-01<br>  Duration: 00:02:45.75, start: 0.025056, bitrate: 131 kb/s<br>    Stream #0:0: Audio: mp3, 44100 Hz, stereo, s16p, 128 kb/s<br>    Metadata:<br>      encoder         : LAME3.97<br>    Stream #0:1: Video: mjpeg, yuvj420p(pc, bt470bg/unknown/unknown), 240x240 [SAR 1:1 DAR 1:1], 90k tbr, 90k tbn, 90k tbc<br>    Metadata:<br>      title           : e<br>      comment         : Cover (front)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>查看视频文件头信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffprobe test.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上就是查看音频文件和视频文件头信息的方式。下面介绍几个更高级的用法。</p>
<ul>
<li><p>输出格式信息format_name、时间长度duration、文件大小size、比特率bit_rate、流的数目nb_streams等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_format test.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>以json格式输出每一个流的最详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -print_format json -show_streams test.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示帧信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_frames test.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看包信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_packets test.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ffplay"><a href="#ffplay" class="headerlink" title="ffplay"></a>ffplay</h4><p>ffplay是以ffmpeg框架为基础，外加渲染音视频库libSDL来构建的媒体文件播放器。它所以来的libSDL是1.2版本的。</p>
<ul>
<li><p>播放音视频文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mp4/黄昏里.mp3</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放一段视频，循环10次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mp4 -loop 10</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>ffplay可以指定使用哪一路音频流或视频流播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mkv -ast 1  // 表示播放视频中的第一路音频流，如果参数ast后面跟的是2，那么就播放第二路音频流，如果没有第二路音频流，就会静音。</span><br><span class="line"></span><br><span class="line">ffplay test.mkv -vst 1</span><br><span class="line">//表示播放第一路视频流，如果参数ast后面跟的是2，那么就播放第二路视频流，如果没有第二路视频流，就会是黑屏即什么都不显示。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放yuv文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay -f rawvideo -video_size width*height testVideo.yuv</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放pcm文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay song.pcm -f s16le -channels 2 -ar 44100</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay -f s16le -ar 44100 -ac 1 song.pcm</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-f 表示音频的格式，你可以使用<code>ffmpeg -formats</code>命令查看支持的格式列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>qis-Mac-mini:tvuDebug qi$ ffmpeg -formats | grep PCM<br> DE alaw            PCM A-law<br> DE f32be           PCM 32-bit floating-point big-endian<br> DE f32le           PCM 32-bit floating-point little-endian<br> DE f64be           PCM 64-bit floating-point big-endian<br> DE f64le           PCM 64-bit floating-point little-endian<br> DE mulaw           PCM mu-law<br> DE s16be           PCM signed 16-bit big-endian<br> DE s16le           PCM signed 16-bit little-endian<br> DE s24be           PCM signed 24-bit big-endian<br> DE s24le           PCM signed 24-bit little-endian<br> DE s32be           PCM signed 32-bit big-endian<br> DE s32le           PCM signed 32-bit little-endian<br> DE s8              PCM signed 8-bit<br> DE u16be           PCM unsigned 16-bit big-endian<br> DE u16le           PCM unsigned 16-bit little-endian<br> DE u24be           PCM unsigned 24-bit big-endian<br> DE u24le           PCM unsigned 24-bit little-endian<br> DE u32be           PCM unsigned 32-bit big-endian<br> DE u32le           PCM unsigned 32-bit little-endian<br> DE u8              PCM unsigned 8-bit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li><p>播放YUV420P格式视频帧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay -f rawvideo -pixel_format yuv420p -s 480*480 texture.yuv</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>播放RGB图像</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay -f rawvideo -pixel_format rgb24 -s 480*480 texture.rgb</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>对于视频播放器，不得不提一个问题就是音画同步，在ffplay中音画同步的实现方式有三种，分别是：以音频为主时间轴作为同步源；以视频为主时间轴作为同步源；以外部时钟为主时间轴作为同步源。</p>
<p>在ffplay中默认的对齐方式就是以音频为基准进行对齐的，那么以音频为对齐基准是如何实现的呢？</p>
<p>播放器收到的视频帧和音频帧都会有时间戳(PTS时钟)来标识它实际什么时刻进行展示。实际的对齐策略如下：比较视频当前的播放时间和音频当前的播放时间，如果视频播放的过快，则通过加大延迟或者重复播放来降低视频播放速度；如果视频播放慢了，则通过减少延迟或者丢帧来追赶音频播放的时间点。关键在于音视频时间的比较以及延迟的计算，当然在比较过程中会设置一个阈值(Threshold)，若超过预设的阈值就应该做调整(丢帧渲染或者重复渲染),这就是对齐策略。</p>
<p>对于ffplay可以明确指定是哪一种对齐方式：</p>
<ul>
<li><p>以音频为基准进行音视频同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mp4 -sync audio</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>以视频为基准进行音视频同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mp4 -sync video</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>以外部时钟为基准进行音视频同步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffplay test.mp4 -sync ext</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ffmpeg"><a href="#ffmpeg" class="headerlink" title="ffmpeg"></a>ffmpeg</h4><p>ffmpeg是强大的媒体文件转换工具。它可以转换任何格式的媒体文件，并且还可以利用自己的AudioFilter以及VideoFilter进行处理和编辑，总之一句话，有了它，进行离线处理视频时可以做任何你想做的事情。</p>
<ul>
<li><p>列出ffmpeg支持的所有格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -formats</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>剪切一段媒体文件，可以是音频或视频文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -ss 00:00:50.0 -codec copy -t 20 output.mp4 // 将文件input.mp4从第50s开始剪切20s的时间，输出到文件output.mp4中，其中-ss指定偏移时间，-t指定时长</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在手机中录制了一个时间比较长的视频无法分享到微信中，那么可以使用ffmpeg将该文件分割为多个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -t 00:00:50 -c copy small-1.mp4 -ss 00:00:50 -codec copy small-2.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取额一个视频文件中的音频文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vn -acodec copy output.m4a</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>使一个视频中的音频静音，即只保留视频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -vcodec copy output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>从MP4文件中抽取视频流导出为裸 H264数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i output.mp4 -an -vcodec copy -bsf:v h264_mp4toannexb output.h264</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用AAC音频的数据和H264的视频生成MP4文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.aac -i test.h264 -acodec copy -bsf:a aac_adtstoasc -vcodec copy -f mp4 output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上述代码中使用了一个名为aac_adtstoasc的bitstream filter, AAC格式也有两种封装格式。</p>
</li>
<li><p>对音频文件的编码格式做转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.wav -acodec libfdk_aac output.aac</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>从WAV音频文件中到处PCM裸数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.wav -acodec pcm_s16le -f s16le output.pcm</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就可以导出用16个bit来表示一个sample的pcm数据了，并且每个sample的字节排列顺序都是小尾端表示的格式，声道数和采样率使用的都是WAV文件的声道数和采样率的PCM数据。</p>
<ul>
<li><p>重新编码视频文件，复制音频流，同时封装到MP4格式的文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.flv -vcodec libx264 -acodec copy output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个MP4格式的视频转换成为git格式的动图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf scale=100:-1 -t 5 -r 10 image.gif</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述代码按照分辨比例不动宽度改为100(使用VideoFilter的scaleFilter)，帧率改为10(-r)，只处理前5秒钟(-t)的视频，生成gif。</p>
<ul>
<li><p>将一个视频的画面部分生成图片，比如要分析一个视频里面的每一帧都是什么内容的时候，可能就需要用到这个命令了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i output.mp4 -r 0.25 frames_%04d.png</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述这个命令每四秒钟截取一帧视频画面生成一张图片，生成的图片从frames_0001.png开始一直递增下去。</p>
<ul>
<li><p>使用一组图片可以组成一个gif，如果你连拍了一组照片，就可以使用下面的命令生成一个gif</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i frames_%04.png -r 5 output.gif</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用音量效果器，可以改变一个音频媒体文件中的音量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.wav -af &apos;volume=0.5&apos; output.wav</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述命令是将input.wav中的音量减小一半，输出到output.wav文件中，可以直接播放来听，或者放到一些音频编辑软件中直接观看波形幅度的效果。</p>
<ul>
<li><p>淡入效果器的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.wav -filter_complex afade=t=in:ss=0:d=5 output.wav</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述命令可以将input.wav文件中的前5s做一个淡入效果，输出到output.wav中，可以将处理之前和处理之后的文件拖到Audacity音频编辑软件中查看波形图。</p>
<ul>
<li><p>淡出效果器的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.wav -filter_complex afade=t=out:st=200:d=5 output.wav</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述命令可以将input.wav文件从200s开始，做5s的淡出效果，并放到output.wav文件中</p>
<p>*将两路声音进行合并，比如要给一段声音加上背景音乐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	ffmpeg -i vocal.wav -i accompany.wav -filter_complex amix=inputs=2:duration=shortest output.wav</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上述命令是将vocal.wav和accompany.wav两个文件记性mix，按照时间长度较短的音频文件的时间长度作为最终输出的output.wav的时间长度</p>
<ul>
<li><p>对声音进行变速但不变调效果器的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i vocal.wav -filter_complex atempo=0.5 output.wav</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述命令是将vocal.wav按照0.5倍的速度尽心刚处理生成output.wav，时间长度将会变为输入的2倍。但是音高是不变的，这就是大家常说的变速不变调。</p>
<ul>
<li>为视频添加水印效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -i changeba_icon.png -filter_complex &apos;[0:v][1:v]overlay=main_w-overlay_w-10:10:1[out]&apos; -map &apos;[out]&apos; output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上述命令包含了几个内置参数，main_w代表主视频宽度，overlay_w代表水印宽度，main_h戴波啊主视频高度，overlay_h代表水印高度。</p>
<ul>
<li>视频提高效果器的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.fly -c:v libx264 -b:v 800k -c:a libfdk_aac -vf eq=brightness=0.25 -f mp4 output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>提亮参数是bitrate，取值范围是从-1.0到1.0,默认值是0</p>
<ul>
<li>为视频增加对比度效果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.flv -c:v libx264 -b:v 800k -c:a libfdk_aac -vf eq=contrast=1.5 -f mp4 output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>对比度参数是contrast,取值范围是从-2.0到2.0,默认值是1.0</p>
<ul>
<li>视频旋转效果器的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -vf &quot;transpose=1&quot; -b:v 600k output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<ul>
<li>视频裁剪效果器的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -an -vf &quot;crop=240:480:120:0&quot; -vcodec libx264 -b:v 600k output.mp4</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h3 id="在mac平台编译出ios开发所用的ffmpeg库"><a href="#在mac平台编译出ios开发所用的ffmpeg库" class="headerlink" title="在mac平台编译出ios开发所用的ffmpeg库"></a>在mac平台编译出ios开发所用的ffmpeg库</h3><h4 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h4><p><code>Homebrew</code>是一款自由及开放源代码的软件包管理系统，用以简化Mac OS X系统上的软件安装过程，最初由马克斯·霍威尔（Max Howell）写成。因其可扩展性得到了一致好评[1]，而在Ruby on Rails社区广为人知。</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fbrew.sh%2F" target="_blank" rel="noopener">how to install HomeBrew</a></p>
<h4 id="下载编译脚本文件"><a href="#下载编译脚本文件" class="headerlink" title="下载编译脚本文件"></a>下载编译脚本文件</h4><p>编译<code>ffmpeg</code>脚本的文件我们用 gas-preprocessor.</p>
<p>下载后把<code>gas-preprocessor.pl</code>拷贝到 <code>/usr/local/bin/</code>目录下，然后为文件开启可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/local/bin/gas-preprocessor.pl</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h4><p>在计算机领域中，Yasm是英特尔x86架构下的一个汇编器和反汇编器。它可以用来编写16位、32位（IA-32）和64位（x86-64）的程序。Yasm是一个完全重写的Netwide汇编器（NASM）。Yasm通常可以与NASM互换使用，并支持x86和x86-64架构。</p>
<p>安装 `yasm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install yasm</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="ffmpeg-ios编译脚本"><a href="#ffmpeg-ios编译脚本" class="headerlink" title="ffmpeg ios编译脚本"></a>ffmpeg ios编译脚本</h4><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmediaios%2FFFmpeg-iOS-build-script" target="_blank" rel="noopener">FFmpeg iOS build script</a></p>
<p>以上是ffmpeg 的编译脚本，能编译出ios平台的库。具体详细信息可查看wiki.</p>
<p>直接运行以下命令编译出我们需要的库(可选择编译那种cpu架构)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ./build-ffmpeg-iOS-framework.sh </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>编译成功后，目录结构如图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0caa15b1d0209?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="在项目中引入ffmpeg"><a href="#在项目中引入ffmpeg" class="headerlink" title="在项目中引入ffmpeg"></a>在项目中引入ffmpeg</h4><p>直接把上面我们编译成功的ffmpeg库<code>FFmpeg-iOS</code>整体拖入工程，然后再加入如下库：</p>
<ul>
<li>libiconv.tdb</li>
<li>libbz2.tbd</li>
<li>libz.tbd</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0cb0e00445c61?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h3 id="简单介绍ffmpeg"><a href="#简单介绍ffmpeg" class="headerlink" title="简单介绍ffmpeg"></a>简单介绍ffmpeg</h3><h4 id="ffmpeg库简介"><a href="#ffmpeg库简介" class="headerlink" title="ffmpeg库简介"></a>ffmpeg库简介</h4><p>ffmpeg一共包含8个库：</p>
<ul>
<li>avcodec : 编解码（最重要的库）</li>
<li>avformat : 封装格式处理</li>
<li>avfilter : 滤镜特效处理</li>
<li>avdevice : 各种设备的输入输出</li>
<li>avutil : 工具库(大部分库都需要这个库的支持)</li>
<li>postproc : 后加工</li>
<li>swresample : 音频采样数据格式转换</li>
<li>swscale : 视频像素数据格式转换</li>
</ul>
<h4 id="ffmpeg数据结构分析"><a href="#ffmpeg数据结构分析" class="headerlink" title="ffmpeg数据结构分析"></a>ffmpeg数据结构分析</h4><ul>
<li>AVFormatContext: 封装格式上下文结构体，也是统领全局的结构体，保存了视频文件封装格式相关信息<ul>
<li>iformat: 输入视频的 AVInputFormat</li>
<li>nb_streams : 输入视频的 AVStream个数</li>
<li>streams : 输入视频的AVStream[] 数组</li>
<li>duration : 输入视频的时长（以微妙为单位）</li>
<li>bit_rate : 输入视频的码率</li>
</ul>
</li>
<li>AVInputFormat:每种封装格式（例如 FLV,MKV,MP4，AVI）对应一个结构体<ul>
<li>name : 封装格式名称</li>
<li>long_name : 封装格式的长名称</li>
<li>extensions : 封装格式的扩展名</li>
<li>id : 封装格式ID</li>
</ul>
</li>
<li>AVStream:视频文件中每个视频(音频)流对应一个该结构体<ul>
<li>id : 序号</li>
<li>codec : 该流对应的AVCodecContext</li>
<li>time_base : 该流的时基</li>
<li>r_frame_rate : 该流的帧率</li>
</ul>
</li>
<li>AVCodecContext:编码器上下文结构体，保存了视频（音频）编解码器相关信息<ul>
<li>codec ： 编解码器的AVCodec</li>
<li>width,height : 图像的宽高（只针对视频）</li>
<li>pix_fmt : 像素格式（只针对视频）</li>
<li>sample_rate : 采样率（只针对音频）</li>
<li>channels : 声道数（只针对音频）</li>
<li>sample_fmt : 采样格式（只针对音频）</li>
</ul>
</li>
<li>AVCodec:每种视频(音频)编解码器（例如 H264解码器）对应一个该结构体<ul>
<li>name :编解码器名称</li>
<li>long_name : 编解码器长名称</li>
<li>type : 编解码器类型</li>
<li>id : 编解码器ID</li>
</ul>
</li>
<li>AVPacket :存储一帧压缩编码数据<ul>
<li>pts : 显示时间戳</li>
<li>dts : 解码时间戳</li>
<li>data : 压缩编码数据</li>
<li>size : 压缩编码数据大小</li>
<li>stream_index : 所属的AVStream</li>
</ul>
</li>
<li>AVFrame :存储一帧解码后像素（采样）数据<ul>
<li>data : 解码后的图像像素数据 （音频采样数据）</li>
<li>linesize : 对视频来说是图像中一行像素大小，对音频来说是整个音频帧的大小</li>
<li>width,height : 图像的宽高(只针对视频)</li>
<li>key_frame : 是否为关键帧 （只针对视频）</li>
<li>pict_type : 帧类型（只针对视频）。 例如 I,B,P</li>
</ul>
</li>
</ul>
<h2 id="利用ffmpeg对实时视频做h264软编码"><a href="#利用ffmpeg对实时视频做h264软编码" class="headerlink" title="利用ffmpeg对实时视频做h264软编码"></a>利用ffmpeg对实时视频做h264软编码</h2><p>大致流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/31/16b0caa165222b9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 christian_smile<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>