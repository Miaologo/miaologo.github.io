<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="日常工作中的一些知识点记录和备份，用于后期查看">
    

    <!--Author-->
    
        <meta name="author" content="christian_smile">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="iOS工程编译优化">
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="日常工作中的一些知识点记录和备份，用于后期查看">
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="45°仰望星空">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>iOS工程编译优化 - 45°仰望星空</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet">

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/klugjo/hexo-theme-clean-blog">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>iOS工程编译优化</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-05-19
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/iOS/">#iOS</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h2 id="iOS-微信编译速度优化分享"><a href="#iOS-微信编译速度优化分享" class="headerlink" title="iOS 微信编译速度优化分享"></a>iOS 微信编译速度优化分享</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/-wgBhE11xEXDS7Hqgq3FjA" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>岁月真是个养猪场，这几年，人胖了，微信代码也翻了。记得 14 年转岗来微信时，用自己笔记本编译微信工程才十来分钟。如今用公司配的 17 年款 27-inch iMac 编译要接近半小时；偶然间更新完代码，又莫名其妙需要全新编译。在这么低的编译效率下，开发心情受到严重影响。于是年初我向上头请示，优化微信编译效率，上头也同意了。</p>
<h2 id="现有方案"><a href="#现有方案" class="headerlink" title="现有方案"></a>现有方案</h2><p>在动手之前，先搜索目前已有方案，大概有这几个优化点：</p>
<h3 id="一、优化工程配置"><a href="#一、优化工程配置" class="headerlink" title="一、优化工程配置"></a>一、优化工程配置</h3><h4 id="1、将-Debug-Information-Format-改为-DWARF"><a href="#1、将-Debug-Information-Format-改为-DWARF" class="headerlink" title="1、将 Debug Information Format 改为 DWARF"></a>1、将 Debug Information Format 改为 DWARF</h4><p>Debug 时是不需要生成符号表，可以检查一下子工程（尤其开源库）有没有设置正确。</p>
<h4 id="2、将-Build-Active-Architecture-Only-改为-Yes"><a href="#2、将-Build-Active-Architecture-Only-改为-Yes" class="headerlink" title="2、将 Build Active Architecture Only 改为 Yes"></a>2、将 Build Active Architecture Only 改为 Yes</h4><p>Debug 时是不需要生成全架构，可以检查一下子工程（尤其开源库）有没有设置正确。</p>
<h4 id="3、优化头文件搜索路径"><a href="#3、优化头文件搜索路径" class="headerlink" title="3、优化头文件搜索路径"></a>3、优化头文件搜索路径</h4><p>避免工程 <code>Header Search Paths</code> 设置了路径递归引用：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AACdeibaZ7NQJ1wZLJ312QatTa4vFxYOcvDYMgSM6lPf4eRQiad9lKhheg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>Xcode 编译源文件时，会根据 <code>Header Search Paths</code> 自动添加 <code>-I</code> 参数，如果递归引用的路径下子目录越多，<code>-I</code> 参数也越多，编译器预处理头文件效率就越低，所以不能简单的设置路径递归引用。同样 <code>Framework Search Paths</code> 也类似处理。</p>
<h3 id="二、使用-CocoaPods-管理第三方库"><a href="#二、使用-CocoaPods-管理第三方库" class="headerlink" title="二、使用 CocoaPods 管理第三方库"></a>二、使用 CocoaPods 管理第三方库</h3><p>这是业界常用的做法，利用 cocoapods 插件 <code>cocoapods-packager</code> 将任意的 pod 打包成 Static Library，省去重复编译的时间；但缺点是不方便调试源码，如果库代码反复修改，需要重新生成二进制并上传到内部服务器，等等。</p>
<h3 id="三、CCache"><a href="#三、CCache" class="headerlink" title="三、CCache"></a>三、CCache</h3><p>CCache 是一个能够把编译的中间产物缓存起来的工具，不需要过多修改项目配置，也不需要修改开发工具链。Xcode 9 有个很偶然的 bug，在源码没有任何修改的情况下经常触发全新编译，用 CCache 很好的解决这一问题。但随着 Xcode 10 修复全量编译问题，这一方案逐步弃用了。</p>
<h3 id="四、distcc"><a href="#四、distcc" class="headerlink" title="四、distcc"></a>四、distcc</h3><p>distcc 是一个分布式编译工具，它原理是把本地多个编译任务分发到网络中多个机器，其他机器编译完成后，再把产物返回给本机上执行链接，最终得到编译结果。</p>
<h3 id="五、硬件解决"><a href="#五、硬件解决" class="headerlink" title="五、硬件解决"></a>五、硬件解决</h3><p>如把 <code>Derived Data</code> 目录放到由内存创建的虚拟磁盘，或者购买最新款的 iMac Pro…</p>
<h2 id="实践过程"><a href="#实践过程" class="headerlink" title="实践过程"></a>实践过程</h2><h3 id="一、优化编译选项"><a href="#一、优化编译选项" class="headerlink" title="一、优化编译选项"></a>一、优化编译选项</h3><h4 id="1、优化头文件搜索路径"><a href="#1、优化头文件搜索路径" class="headerlink" title="1、优化头文件搜索路径"></a>1、优化头文件搜索路径</h4><p>把一些递归引用路径去了后，整体编译速度快了 20s。</p>
<h4 id="2、关闭-Enable-Index-While-Building-Functionality"><a href="#2、关闭-Enable-Index-While-Building-Functionality" class="headerlink" title="2、关闭 Enable Index-While-Building Functionality"></a>2、关闭 Enable Index-While-Building Functionality</h4><p>这选项无意中找到的（Xcode 9 的新特性？），默认打开，作用是 Xcode 编译时会顺带建立代码索引，但影响编译速度。关闭后整体编译速度快 80s（Xcode 会换回以前的方式，在空闲时间建立代码索引）。</p>
<h3 id="二、优化-kinda"><a href="#二、优化-kinda" class="headerlink" title="二、优化 kinda"></a>二、优化 kinda</h3><p>kinda 是今年引入支付跨平台框架（C++），但编译速度奇慢，一个源文件编译都要 30s。另外生成的二进制大小在 App 占比较高，感觉有不少冗余代码，理论上减少冗余代码也能加快编译速度。经过分析 LinkMap 文件和使用 Xcode Preprocess 某些源文件，发现有以下问题：</p>
<ul>
<li>proto 文件生成的代码较多</li>
<li>某个基类/宏使用了大量模版</li>
</ul>
<p>对于问题一，可以设置 proto 文件选项为 <code>optimize_for=CODE_SIZE</code> 来让 protobuf 编译器生成精简版代码。但我是用自己的工具生成（具体原理可看<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207986417&amp;idx=1&amp;sn=77ea7d8e4f8ab7b59111e78c86ccfe66&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">这里</a>），代码更少。</p>
<p>对于问题二，由于模版是编译期间的多态（增加代码膨胀和编译时间），所以可以把模版基类改成虚基类这种运行时的多态；另外推荐使用 <code>hyper_function</code> 取代 <code>std::function</code>，使得基类用通用函数指针，就能存储任意 lambda 回调函数，从而避免基类模板化。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename Request, typename Response&gt;</span><br><span class="line">class BaseCgi &#123;</span><br><span class="line">public:</span><br><span class="line">    BaseCgi(Request request, std::function&lt;void(Response &amp;)&gt; &amp;callback) &#123;</span><br><span class="line">        _request = request;</span><br><span class="line">        _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void onRequest(std::vector&lt;uint8_t&gt; &amp;outData) &#123;</span><br><span class="line">        _request.toData(outData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void onResponse(std::vector&lt;uint8_t&gt; &amp;inData) &#123;</span><br><span class="line">        Response response;</span><br><span class="line">        response.fromData(inData);</span><br><span class="line">        callback(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    Request _request;</span><br><span class="line">    std::function&lt;void(Response &amp;)&gt; _callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CgiA : public BaseCgi&lt;RequestA, ResponseA&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    CgiA(RequestA &amp;request, std::function&lt;void(ResponseA &amp;)&gt; &amp;callback) :</span><br><span class="line">        BaseCgi(request, callback) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class BaseRequest &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void toData(std::vector&lt;uint8_t&gt; &amp;outData) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BaseResponse &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fromData(std::vector&lt;uint8_t&gt; &amp;outData) = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BaseCgi &#123;</span><br><span class="line">public:</span><br><span class="line">    template &lt;typename Request, typename Response&gt;</span><br><span class="line">    BaseCgi(Request &amp;request, hyper_function&lt;void(Response &amp;)&gt; callback) &#123;</span><br><span class="line">        _request = new Request(request);</span><br><span class="line">        _response = new Response;</span><br><span class="line">        _callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void onRequest(std::vector&lt;uint8_t&gt; &amp;outData) &#123;</span><br><span class="line">        _request-&gt;toData(outData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void onResponse(std::vector&lt;uint8_t&gt; &amp;inData) &#123;</span><br><span class="line">        _response-&gt;fromData(inData);</span><br><span class="line">        _callback(*_response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    BaseRequest *_request;</span><br><span class="line">    BaseResponse *_response;</span><br><span class="line">    hyper_function&lt;void(BaseResponse &amp;)&gt; _callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class RequestA : public BaseRequest &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">class ResponseA : public BaseResponse &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">class CgiA : public BaseCgi &#123;</span><br><span class="line">public:</span><br><span class="line">    CgiA(RequestA &amp;request, hyper_function&lt;void(ResponseA &amp;)&gt; &amp;callback) :</span><br><span class="line">        BaseCgi(request, callback) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>BaseCgi</code> 由模版基类变成只有构造函数是模板的基类，<code>onRequest</code> 和 <code>onResponse</code> 逻辑代码并不因为基类模版实例化而被“复制黏贴”。经过上述优化，整体编译速度快了 70s，而 kinda 二进制也减少了 60%，效果特别明显。</p>
<h3 id="三、使用-PCH-预编译头文件"><a href="#三、使用-PCH-预编译头文件" class="headerlink" title="三、使用 PCH 预编译头文件"></a>三、使用 PCH 预编译头文件</h3><p>PCH（Precompile Prefix Header File）文件，也就是预编译头文件，其文件里的内容能被项目中的其他所有源文件访问。通常放一些通用的宏和头文件，方便编写代码，提高效率。另外 PCH 文件预编译完成后，后面用到 PCH 文件的源文件编译速度也会加快。缺点是 PCH 文件和 PCH 引用到的头文件内容一旦发生变化，引用到 PCH 的所有源文件都要重新编译。所以使用时要谨慎。在 Xcode 里设置 <code>Prefix Header</code> 和 <code>Precompile Prefix Header</code> 即可使用 PCH 文件并对它进行预编译：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AA1cz5FVVDYxkpAJqxXVsggm5ePzibQrjQAwGR7Zc3YnE271uuQoRlx0w/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>微信使用 PCH 预编译后，编译速度提升非常可观，快了接近 280s。</p>
<h2 id="终极优化"><a href="#终极优化" class="headerlink" title="终极优化"></a>终极优化</h2><p>通过上述优化，微信工程的编译时间由原来的 <strong>1,626.4s</strong> 下降到 <strong>1,182.8s</strong>，快了将近 <strong>450s</strong>，但仍然需要 20 分钟，令人不满意。如果继续优化，得从编译器下手。正如我们平常做的客户端性能优化，在优化之前，先分析原理，输出每个地方的耗时，针对耗时做相对应的优化。</p>
<h3 id="一、编译原理"><a href="#一、编译原理" class="headerlink" title="一、编译原理"></a>一、编译原理</h3><p>编译器，是把一种语言（通常是高级语言）转换为另一种语言（通常是低级语言）的程序。大多数编译器由三部分组成：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAMdpiajV7nBtJTm4QSPsUJpLHny03Db7Z1N7Wyp1BiaeoQMldGcSgM4zw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ul>
<li>前端（Frontend）：负责解析源码，检查错误，生成抽象语法树（AST），并把 AST 转化成类汇编中间代码</li>
<li>优化器（Optimizer）：对中间代码进行架构无关的优化，提高运行效率，减少代码体积，例如删除 <code>if (0)</code> 无效分支</li>
<li>后端（Backend）：把中间代码转换成目标平台的机器码</li>
</ul>
<p>LLVM 实现了更通用的编译框架，它提供了一系列模块化的编译器组件和工具链。首先它定义了一种 LLVM IR（Intermediate Representation，中间表达码）。Frontend 把原始语言转换成 LLVM IR；LLVM Optimizer 优化 LLVM IR；Backend 把 LLVM IR 转换为目标平台的机器语言。这样一来，不管是新的语言，还是新的平台，只要实现对应的 Frontend 和 Backend，新的编译器就出来了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAgLZDqJlhHCabicL9o4H5P33A2SFDRKMYdEF9pIl1WYx7lRGCem6THEg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>在 Xcode，C/C++/ObjC 的编译器是 Clang（前端）+LLVM（后端），简称 Clang。Clang 的编译过程有这几个阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  clang -ccc-print-phases main.m</span><br><span class="line">0: input, &quot;main.m&quot;, objective-c</span><br><span class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</span><br><span class="line">2: compiler, &#123;1&#125;, ir</span><br><span class="line">3: backend, &#123;2&#125;, assembler</span><br><span class="line">4: assembler, &#123;3&#125;, object</span><br><span class="line">5: linker, &#123;4&#125;, image</span><br><span class="line">6: bind-arch, &quot;x86_64&quot;, &#123;5&#125;, image</span><br></pre></td></tr></table></figure>
<h4 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h4><p>这阶段的工作主要是头文件导入，宏展开/替换，预编译指令处理，以及注释的去除。</p>
<h4 id="2、编译"><a href="#2、编译" class="headerlink" title="2、编译"></a>2、编译</h4><p>这阶段做的事情比较多，主要有：</p>
<ul>
<li>词法分析（Lexical Analysis）：将代码转换成一系列 token，如大中小括号 <code>paren&#39;()&#39;</code> <code>square&#39;[]&#39;</code> <code>brace&#39;{}&#39;</code>、标识符 <code>identifier</code>、字符串 <code>string_literal</code>、数字常量 <code>numeric_constant</code> 等等</li>
<li>语法分析（Semantic Analysis）：将 token 流组成抽象语法树 AST</li>
<li>静态分析（Static Analysis）：检查代码错误，例如参数类型是否错误，调用对象方法是否有实现</li>
<li>中间代码生成（Code Generation）：将语法树自顶向下遍历逐步翻译成 LLVM IR</li>
</ul>
<h4 id="3、生成汇编代码"><a href="#3、生成汇编代码" class="headerlink" title="3、生成汇编代码"></a>3、生成汇编代码</h4><p>LLVM 将 LLVM IR 生成当前平台的汇编代码，期间 LLVM 根据编译设置的优化级别 <code>Optimization Level</code> 做对应的优化（Optimize），例如 Debug 的 <code>-O0</code> 不需要优化，而 Release 的 <code>-Os</code> 是尽可能优化代码效率并减少体积。</p>
<h4 id="4、生成目标文件"><a href="#4、生成目标文件" class="headerlink" title="4、生成目标文件"></a>4、生成目标文件</h4><p>汇编器（Assembler）将汇编代码转换为机器代码，它会创建一个目标对象文件，以 .o 结尾。</p>
<h4 id="5、链接"><a href="#5、链接" class="headerlink" title="5、链接"></a>5、链接</h4><p>链接器（Linker）把若干个目标文件链接在一起，生成可执行文件。</p>
<h3 id="二、分析耗时"><a href="#二、分析耗时" class="headerlink" title="二、分析耗时"></a>二、分析耗时</h3><p>Clang/LLVM 编译器是开源的，我们可以从官网下载其源码，根据上述编译过程，在每个编译阶段埋点输出耗时，生成定制化的编译器。在自己准备动手的前一周，国外大神 <strong>Aras Pranckevičius</strong> 已经在 LLVM 项目提交了 rL357340 修改：clang 增加 <code>-ftime-trace</code> 选项，编译时生成 Chrome（chrome://tracing） JSON 格式的耗时报告，列出所有阶段的耗时。效果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAYfr1CX93r5US7BicH7evib8bQYdCEpq3cw0BWCXlRwKGiaJop0fXpV8GQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ul>
<li>整体编译（ExecuteCompiler）耗时 8,423.8ms</li>
<li>其中前端（Frontend）耗时 5,307.9ms，后端（Backend）耗时 3,009.6ms</li>
<li>而前端编译里头文件 SourceA 耗时 xx ms，B 耗时 xx ms，…</li>
<li>头文件处理里 Parse ClassA 耗时 xx ms，B 耗时 xx ms，…</li>
<li>等等</li>
</ul>
<p>这就是我想要的耗时报告！接下来修改工程 <code>CC={YOUR PATH}/clang</code>，让 Xcode 编译时使用自己的编译器；同时编译选项 <code>OTHER_CFLAGS</code> 后面增加 <code>-ftime-trace</code>，每个源文件编译后输出耗时报告。最终把所有报告汇聚起来，形成整体的编译耗时：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAefbhZU3jeoYQIBq2J2dLy6L0o7xVJ1VRGb71M5QblEC9GuUwH6m9AA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>由整体耗时可以看出，编译器前端处理（Frontend）耗时 7,659.2s，占整体 87%；而前端处理下头文件处理（Source）耗时 7,146.2s，占整体 71.9%！猜测头文件嵌套严重，每个源文件都要引入几十个甚至几百个头文件，每个头文件源码要做预处理、词法分析、语法分析等等。实际上源文件不需要使用某些头文件里的定义（如 class、function），所以编译时间才那么长。</p>
<p>于是又写了个工具，统计所有头文件被引用次数、总处理时间、头文件分组（指一个耗时顶部的头文件所引用到的所有子头文件的集合），列出一份表格（截取 Top10）：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAOFIyUiaicvCiaNX0GEzicXTVMMbMXdhC6ZnibibOGulYySPpwsNicrdmgiasMA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>Header1 处理时间 1187.7s，被引用 2,304 次；Header2 处理时间 1,124.9s，被引用 3,831 次；后面 Header3～10 都是被 Header1 引用。所以可以尝试优化 TopN 头文件里的头文件引用，尽量不包含其他头文件。</p>
<h3 id="三、解决耗时"><a href="#三、解决耗时" class="headerlink" title="三、解决耗时"></a>三、解决耗时</h3><p>通常我们写代码时，如果用到某个类，就直接 include 该类声明所在头文件，但在头文件，我们可以用前置声明解决。因此优化头文件思路很简单，就是能用前置声明，就用前置声明替代 include。实际上改动量非常大，我跟组内另外的同事 vakeee 分工优化 Header1 和 Header2，花了整整 5 个工作日，才改完。效果还是有，整体编译时间减少 80s。</p>
<p>但需要优化的头文件还有几十个，我们不可能继续做这种体力活。因此我们可以做这样的工具，通过 AST 找到代码里出现的标识符（包括类型、函数、宏），以及标识符定义所在文件，然后分析是否需要 include 它定义所在文件。</p>
<p>先看看代码如何转换 AST，如以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// HeaderA.h</span><br><span class="line">struct StructA &#123;</span><br><span class="line">    int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// HeaderB.h</span><br><span class="line">struct StructB &#123;</span><br><span class="line">    int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// main.c</span><br><span class="line">#include &quot;HeaderA.h&quot;</span><br><span class="line">#include &quot;HeaderB.h&quot;</span><br><span class="line"></span><br><span class="line">int testAndReturn(struct StructA *a, struct StructB *b) &#123;</span><br><span class="line">    return a-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  TestContainer clang -Xclang -ast-dump -fsyntax-only main.c</span><br><span class="line">TranslationUnitDecl 0x7f8f36834208 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</span><br><span class="line">|-RecordDecl 0x7faa62831d78 &lt;./HeaderA.h:12:1, line:14:1&gt; line:12:8 struct StructA definition</span><br><span class="line">| `-FieldDecl 0x7faa6383da38 &lt;line:13:2, col:6&gt; col:6 referenced val &apos;int&apos;</span><br><span class="line">|-RecordDecl 0x7faa6383da80 &lt;./HeaderB.h:12:1, line:14:1&gt; line:12:8 struct StructB definition</span><br><span class="line">| `-FieldDecl 0x7faa6383db38 &lt;line:13:2, col:6&gt; col:6 val &apos;int&apos;</span><br><span class="line">`-FunctionDecl 0x7faa6383de50 &lt;main.c:35:1, line:37:1&gt; line:35:5 testAndReturn &apos;int (struct StructA *, struct StructB *)&apos;</span><br><span class="line">  |-ParmVarDecl 0x7faa6383dc30 &lt;col:19, col:35&gt; col:35 used a &apos;struct StructA *&apos;</span><br><span class="line">  |-ParmVarDecl 0x7faa6383dd40 &lt;col:38, col:54&gt; col:54 b &apos;struct StructB *&apos;</span><br><span class="line">  `-CompoundStmt 0x7faa6383dfc8 &lt;col:57, line:37:1&gt;</span><br><span class="line">    `-ReturnStmt 0x7faa6383dfb8 &lt;line:36:2, col:12&gt;</span><br><span class="line">      `-ImplicitCastExpr 0x7faa6383dfa0 &lt;col:9, col:12&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">        `-MemberExpr 0x7faa6383df70 &lt;col:9, col:12&gt; &apos;int&apos; lvalue -&gt;val 0x7faa6383da38</span><br><span class="line">          `-ImplicitCastExpr 0x7faa6383df58 &lt;col:9&gt; &apos;struct StructA *&apos; &lt;LValueToRValue&gt;</span><br><span class="line">            `-DeclRefExpr 0x7faa6383df38 &lt;col:9&gt; &apos;struct StructA *&apos; lvalue ParmVar 0x7faa6383dc30 &apos;a&apos; &apos;struct StructA *&apos;</span><br></pre></td></tr></table></figure>
<p>从上可以看出，每一行包括 AST Node 的类型、所在位置（文件名，行号，列号）和结点描述信息。头文件定义的类也包含进 AST 中。AST Node 常见类型有 Decl（如 RecordDecl 结构体定义，FunctionDecl 函数定义）、Stmt（如 CompoundStmt 函数体括号内实现）。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAsSXcGgv8ggxicvibHkN7SNtHpoPYveaT37XOPjMTeHNo4vu21JHQ3NUA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>Clang AST 有三个重要的基类：ASTFrontendAction、ASTConsumer 以及 RecursiveASTVisitor。ClangTool 类读入命令行配置项后初始化 CompilerInstance；CompilerInstance 成员函数 <code>ExcutionAction</code> 会调用 ASTFrontendAction 3 个成员函数 <code>BeginSourceFile</code>（准备遍历 AST）、<code>Execute</code>（解析 AST）、<code>EndSourceFileAction</code>（结束遍历）。ASTFrontendAction 有个重要的纯虚函数 <code>CreateASTConsumer</code>（会被自己 <code>BeginSourceFile</code> 调用），用于返回读取 AST 的 ASTConsumer 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyFrontendAction : public clang::ASTFrontendAction &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual std::unique_ptr&lt;clang::ASTConsumer&gt; CreateASTConsumer(clang::CompilerInstance &amp;CI, llvm::StringRef file) override &#123;</span><br><span class="line">        TheRewriter.setSourceMgr(CI.getASTContext().getSourceManager(), CI.getASTContext().getLangOpts());</span><br><span class="line">        return llvm::make_unique&lt;MyASTConsumer&gt;(&amp;CI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char **argv) &#123;</span><br><span class="line">    clang::tooling::CommonOptionsParser op(argc, argv, OptsCategory);</span><br><span class="line">    clang::tooling::ClangTool Tool(op.getCompilations(), op.getSourcePathList());</span><br><span class="line">    int result = Tool.run(clang::tooling::newFrontendActionFactory&lt;MyFrontendAction&gt;().get());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ASTConsumer 有若干个可以 override 的方法，用来接收 AST 解析过程中的回调，其中之一是工具用到的 <code>HandleTranslationUnit</code> 方法。当编译单元 TranslationUnit 的 AST 完整解析后，<code>HandleTranslationUnit</code> 会被回调。我们在 <code>HandleTranslationUnit</code> 使用 RecursiveASTVisitor 对象以深度优先的方式遍历 AST 所有结点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyASTVisitor</span><br><span class="line">: public clang::RecursiveASTVisitor&lt;MyASTVisitor&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit MyASTVisitor(clang::ASTContext *Ctx) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    bool VisitFunctionDecl(clang::FunctionDecl* decl) &#123;</span><br><span class="line">        // FunctionDecl 下的所有参数声明允许前置声明取代 include</span><br><span class="line">        // 如上面 Demo 代码里 StructA、StructB</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool VisitMemberExpr(clang::MemberExpr* expr) &#123;</span><br><span class="line">        // 被引用的成员所在的类，需要 include 它定义所在文件</span><br><span class="line">        // 如 StructA</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool VisitXXX(XXX) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 同一个类型，可能出现若干次判定结果</span><br><span class="line">    // 如果其中一个判断的结果需要 include，则 include</span><br><span class="line">    // 否则使用前置声明代替 include</span><br><span class="line">    // 例如 StructA 只能 include，StructB 可以前置声明</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class MyASTConsumer : public clang::ASTConsumer &#123;</span><br><span class="line">private:</span><br><span class="line">    MyASTVisitor Visitor;</span><br><span class="line">public:</span><br><span class="line">    explicit MyASTConsumer(clang::CompilerInstance *aCI)</span><br><span class="line">    : Visitor(&amp;(aCI-&gt;getASTContext())) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    void HandleTranslationUnit(clang::ASTContext &amp;context) override &#123;</span><br><span class="line">        clang::TranslationUnitDecl *decl = context.getTranslationUnitDecl();</span><br><span class="line">        Visitor.TraverseTranslationUnitDecl(decl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>工具框架大致如上所示。不过早在 2011 年 Google 内部做了个基于 Clang libTooling 的工具 include-what-you-use，用来整理 C/C++ 头文件，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  include-what-you-use main.c</span><br><span class="line">HeaderA.h has correct #includes/fwd-decls)</span><br><span class="line"></span><br><span class="line">HeaderB.h has correct #includes/fwd-decls)</span><br><span class="line"></span><br><span class="line">main.c should add these lines:</span><br><span class="line">struct StructB;</span><br><span class="line"></span><br><span class="line">main.c should remove these lines:</span><br><span class="line">- #include &quot;HeaderB.h&quot;  // lines 2-2</span><br><span class="line"></span><br><span class="line">The full include-list for main.c:</span><br><span class="line">#include &quot;HeaderA.h&quot;  // for StructA</span><br><span class="line">struct StructB;</span><br></pre></td></tr></table></figure>
<p>我们在 IWYU 基础上，增加了 ObjC 语言的支持，并增强它的逻辑，让结果更好看（通常 IWYU 处理完后，会引入很多头文件和前置声明，我们做剪枝处理，进一步去掉多余的头文件和前置声明，篇幅限制就不多做解释了）。</p>
<p>微信源码通过工具优化头文件引入后，整体编译时间降到了 <strong>710s</strong>。另外头文件依赖的减少，也能降低因修改头文件引起大规模源码重编的可能性。我们再用编译耗时分析工具分析当前瓶颈：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AAckQ9MTPv6IiaqICKvSeWQfh1icKic6YfzrC0o0aytB78ia2bX8TOKJDQ9g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>WCDB 头文件处理时间太长了，业务代码（如 Model 类）没有很好的隔离 WCDB 代码，把 WINQ 暴露出去，外面被动 include WCDB 头文件。解决方法有很多，例如 WCDB 相关放 category 头文件（XXModel+WCDB.h）里引入，或者跟其他库一样，把 <code></code> 放 PCH。</p>
<p>最终编译时间优化到 540s 以下，是原来的三分之一，编译效率得到巨大的提升。</p>
<h2 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h2><p>总结微信的编译优化方案：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/csvJ6rH9Mcu5afAVl9zMr84UF3cJC3AA9aWoFngq9mNy6I4NARLHVCLOricfWeq2ZSRBZ6cbIlh4PyoD3iaXfNqw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<ul>
<li>A、优化头文件搜索路径</li>
<li>B、关闭 Enable Index-While-Building Functionality</li>
<li>C、优化 PB/模版，减少冗余代码</li>
<li>D、使用 PCH 预编译</li>
<li>E、使用工具优化头文件引入；尽量避免头文件里包含 C++ 标准库</li>
</ul>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>期待公司的蓝盾分布式编译 for ObjC；另外可以把业务代码模块化，项目文件按模块加载，目前 kinda/小程序/mars 在很好的实践中。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><p>如何将 iOS 项目的编译速度提高5倍</p>
</li>
<li><p>深入剖析 iOS 编译 Clang / LLVM</p>
</li>
<li><p>Clang之语法抽象语法树AST</p>
</li>
<li><p>time-trace: timeline / flame chart profiler for Clang</p>
</li>
<li><p>Introduction to the Clang AST</p>
</li>
</ul>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 christian_smile<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>